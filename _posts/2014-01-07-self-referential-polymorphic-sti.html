---
layout: post
title: Self-Referential, Polymorphic, STI, Decorated, Many-to-Many Relationship in
  Rails 4
date: '2014-01-07T21:47:00.001-08:00'
author: Larry Reid
tags:
- Ruby on Rails
modified_time: '2014-01-07T21:51:40.159-08:00'
blogger_id: tag:blogger.com,1999:blog-5778824359157275227.post-583119077619162219
blogger_orig_url: http://technopragmatica.blogspot.com/2014/01/self-referential-polymorphic-sti.html
---

<h2 id="preamble">Preamble</h2>I wanted to model connections à la connections in LinkedIn or Facebook in a Rails application. This means a many-to-many association between instances of the same class. That caused me some grief trying to get it hooked up right because you can’t rely on Rails to figure everything out.<br />The other trick in my application is that the people involved in the connections might be users who have registered to use the application, or they might be people created by a registered user, but who aren’t registered to user the application. <br />Concretely, and hopefully more clearly, I have “users”, who have registered, and I have people who can be involved connections. In my app the people who aren’t registered users are “patients”.<br />In the course of trying to get this all to work I stumbled across three approaches to this type of problem:<br /><ol><li>Polymorphic classes</li><li>Single Table Inheritance (STI)</li><li><a href="http://en.wikipedia.org/wiki/Decorator_pattern">Decorator pattern</a></li></ol>The combination of the many-to-many combined with the two classes took a lot of work to get straight. The <a href="http://guides.rubyonrails.org/association_basics.html%20and%20migrations:%20http://guides.rubyonrails.org/migrations.html">Rails Guides</a> were a great starting point, but I find that specifying Rails associations can be tricky if it’s not completely straightforward, and especially when you start chaining them together.<br />In the end, I decided to go with the Decorator pattern. But I’ll start with the one I threw out first: Polymorphic.<br /><h2 id="polymorphic">Polymorphic</h2>I got pretty far with polymorphic associations, but I couldn’t figure out how I was going to get a list of all people (patients and users) connected to another person. I could either get all patients or all users from the methods that the Rails associations gave me, but not a list of all together.<br />I realized in writing the preamble above that I probably should have realized that what I was trying to model wasn’t really a polymorphic situation. Polymorphic in the examples I saw was used to connect an object to another object from any one of a number of unrelated classes. Of course, hindsight is 20/20.<br /><a href="http://www.brentmc79.com/posts/polymorphic-many-to-many-associations-in-rails">This post</a> convinced me that trying to get a list of all people wasn’t going to come naturally from a polymorphic approach, so I stopped pursuing it.<br /><div class="se-section-delimiter"></div><h2 id="single-table-inheritance">Single Table Inheritance</h2>I got fired up about single table inheritance (STI) as I was reading about how to make the polymorphic approach work. A good brief write up is here: <a href="http://blog.thirst.co/post/14885390861/rails-single-table-inheritance">http://blog.thirst.co/post/14885390861/rails-single-table-inheritance</a>. The Railscast is here: <a href="http://railscasts.com/episodes/394-sti-and-polymorphic-associations">http://railscasts.com/episodes/394-sti-and-polymorphic-associations</a> (sorry, it’s a pro Railscast so it’s behind a paywall).<br />Others say I shouldn’t do STI. People say it can cause problems. One problem is if the type of an object will change, and change because of user input, it’s hard to handle. The view and controller are fixed to a certain object, so you can’t change the object type based on user input. <br />So here’s the code. First, create the models:<br /><pre><code>rails g model person name:string type:string provider:string uid:string<br />rails g model link person_a:references person_b:references b_is:string<br /></code></pre>person.rb<br /><pre><code>class Person &lt; ActiveRecord::Base<br />  has_many :links, foreign_key: "person_a_id"<br />  has_many :people, :through =&gt; :links, :source =&gt; :person_b<br />  scope :patients, -&gt; { where(type: "Patient") }<br />  scope :users, -&gt; { where(type: "User") }<br />end<br /></code></pre>user.rb (obviously there will be functionality here, but this is what I needed to get the associations to work):<br /><pre><code>class User &lt; Person<br />end<br /></code></pre>patient.rb (as with user.rb, functionality will come later):<br /><pre><code>class Patient &lt; Person<br />end<br /></code></pre>link.rb<br /><pre><code>class Link &lt; ActiveRecord::Base<br />  belongs_to :person_a, class_name: "Person"<br />  belongs_to :person_b, class_name: "Person"<br />end<br /></code></pre>It was a little hard to get the associations to work. The key to making the <code>has_many :links,...</code> in <code>person.rb</code> work was the <code>, class_name: "Person"</code> on the association in <code>link.rb</code>. <br />With the above, I can do things like:<br /><pre><code>person = Person.find(1).first<br />person.people.first.name<br />person.people.patients.first.name<br />person.people.users.first.name<br /></code></pre>That’s all pretty sweet, and I really considered using this approach. In fact, I may return to it. There’s a lot left to do with my application. However, I’m pretty sure that I will need to deal with cases like a registered user corresponding to multiple patients (e.g. people get created under different names). Eventually I need a way to consolidate them.<br /><h2 id="decorator">Decorator</h2>In the end, perhaps the simplest was the best. I just decorated a person with an instance of a user when the person is a registered user. (This allows multiple people for a user, which might be useful for consolidating duplicate people.) <br />Here’s what I did:<br />Generate the models:<br /><pre><code>rails g model link person_a:references person_b:references b_is:string<br />rails g model person user:references name:string<br />rails g model user uid:string name:string provider:string<br /></code></pre>person.rb<br /><pre><code>require 'person_helper'<br /><br />class Person &lt; ActiveRecord::Base<br />  belongs_to :user<br />  has_many :links, foreign_key: :person_a_id<br />  has_many :people, through: :links, source: :person_b<br /><br />  include PersonHelper<br />end<br /></code></pre>I thought the person model should have <code>has_one</code> instead of <code>belongs_to</code>, but that would put the foreign key in the wrong model.<br />user.rb<br /><pre><code>require 'person_helper'<br /><br />class User &lt; ActiveRecord::Base<br />  has_many :identities, class_name: "Person"<br />  has_many :links, through: :identities<br />  has_many :people, through: :links, :source =&gt; :person_b<br /><br />  include PersonHelper<br />end<br /></code></pre>lib/person_helper.rb<br /><pre><code>module PersonHelper<br />  def users<br />    people.select { |person| ! person.user_id.nil? }<br />  end<br /><br />  def patients<br />    people.select { |person| person.user_id.nil? }<br />  end<br />end<br /></code></pre>link.rb<br /><pre><code>class Link &lt; ActiveRecord::Base<br />  belongs_to :person_a, class_name: "Person"<br />  belongs_to :person_b, class_name: "Person"<br />end<br /></code></pre>With the above, I can do things like:<br /><pre><code>person = Person.find(1).first<br />person.people.first.name<br />person.patients.first.name<br />person.users.first.name<br />user = User.find(2).first<br />user.users.first.name<br /></code></pre>Again, sweet. Same number of files at the STI version. Instead of subclassing, common functionality is handled by a mixin module.<br /><h2 id="postscript">Postscript</h2>Another thing people don’t seem to like about STI is that it’s easy to end up with a big table full of all sorts of columns used only in a few places. Most modern database management systems aren’t going to waste a significant amount of space for unused columns, so I’m not sure what the problem is.<br />However, it got me thinking if there isn’t a way in Rails to have more than one table under a model. Or more to the point, could you have a table for the base model class, and a different table for each of the subclasses, and have Rails manage all the saving a retrieving.<br />I’m sure I’m not the first person to think of this. But I’m not going to go looking for it right now.<br /><h2 id="other-resources">Other Resources</h2>Rails 4 guides on associations: <a href="http://guides.rubyonrails.org/association_basics.html">http://guides.rubyonrails.org/association_basics.html</a> and migrations: <a href="http://guides.rubyonrails.org/migrations.html">http://guides.rubyonrails.org/migrations.html</a>.<br />Ryan Bates’ Railscast on self-referential associations: <a href="http://railscasts.com/episodes/163-self-referential-association">http://railscasts.com/episodes/163-self-referential-association</a>, and on polymorphic associations: <a href="http://railscasts.com/episodes/154-polymorphic-association">http://railscasts.com/episodes/154-polymorphic-association</a>.